From 19218ec9b77b3a49fdf9bfc4350d3b4ae937805b Mon Sep 17 00:00:00 2001
From: Mark Wong <mark.wong@enterprisedb.com>
Date: Tue, 4 Apr 2023 15:34:21 -0700
Subject: [PATCH] Match postgresql stored procedures to oracle

Use the same procedures, as best we can, between PostgreSQL and Oracle
when ora_compatible and storec procedures are set for PostgreSQL.

Here are some noted differences:

* Removed pragma statements.
* Create the same indexes as Oracle when ora_compatible is set for
  PostgreSQL.
* Explicitly cast floating point numbers resulting from integer division
  when indexing an array.
* Renamed timestamp to timstamp2 when used as a variable name, as
  opposed to using quoting.
* PostgreSQL doesn't currently support updating views without triggers,
  so updating the stock table while joining to the item table at the
  same time using the UPDATE...FROM  construct.
* PostgreSQL doesn't currently support aggregate functions in RETURNING
  clauses.  Rewrite the FORALL...RETURNING sum()... as a CTE using a FOR
  loop.

The table definitions are already the same between PostgreSQL and Oracle
when ora_compatible is set for PostgreSQL.
---
 src/postgresql/pgoltp.tcl | 882 ++++++++++++++++++++++----------------
 1 file changed, 508 insertions(+), 374 deletions(-)

diff --git a/src/postgresql/pgoltp.tcl b/src/postgresql/pgoltp.tcl
index ff32f2c..97f65ed 100755
--- a/src/postgresql/pgoltp.tcl
+++ b/src/postgresql/pgoltp.tcl
@@ -46,414 +46,535 @@ proc CreateStoredProcs { lda ora_compatible citus_compatible pg_storedprocs } {
             $$ LANGUAGE 'plpgsql' STRICT;
         }
         set sql(2) { CREATE OR REPLACE PROCEDURE NEWORD (
-            no_w_id		INTEGER,
-            no_max_w_id		INTEGER,
-            no_d_id		INTEGER,
-            no_c_id		INTEGER,
-            no_o_ol_cnt		INTEGER,
-            no_c_discount		OUT NUMBER,
+            no_w_id		BINARY_INTEGER,
+            no_max_w_id		BINARY_INTEGER,
+            no_d_id		    BINARY_INTEGER,
+            no_c_id		    BINARY_INTEGER,
+            no_o_ol_cnt		BINARY_INTEGER,
+            no_c_discount	OUT NUMBER,
             no_c_last		OUT VARCHAR2,
             no_c_credit		OUT VARCHAR2,
             no_d_tax		OUT NUMBER,
             no_w_tax		OUT NUMBER,
-            no_d_next_o_id		IN OUT INTEGER,
-            tstamp		IN DATE )
+            no_d_next_o_id	OUT BINARY_INTEGER,
+            timestamp2		IN DATE )
             IS
-            no_ol_supply_w_id	INTEGER;
-            no_ol_i_id		NUMBER;
-            no_ol_quantity		NUMBER;
-            no_o_all_local		INTEGER;
-            o_id			INTEGER;
-            no_i_name		VARCHAR2(24);
-            no_i_price		NUMBER(5,2);
-            no_i_data		VARCHAR2(50);
-            no_s_quantity		NUMBER(6);
-            no_ol_amount		NUMBER(6,2);
-            no_s_dist_01		CHAR(24);
-            no_s_dist_02		CHAR(24);
-            no_s_dist_03		CHAR(24);
-            no_s_dist_04		CHAR(24);
-            no_s_dist_05		CHAR(24);
-            no_s_dist_06		CHAR(24);
-            no_s_dist_07		CHAR(24);
-            no_s_dist_08		CHAR(24);
-            no_s_dist_09		CHAR(24);
-            no_s_dist_10		CHAR(24);
-            no_ol_dist_info		CHAR(24);
-            no_s_data		VARCHAR2(50);
-            x			NUMBER;
-            rbk			NUMBER;
+            order_amount        NUMBER;
+            no_o_all_local		BINARY_INTEGER;
+            loop_counter        BINARY_INTEGER;
+            not_serializable		EXCEPTION;
+            deadlock			EXCEPTION;
+            snapshot_too_old		EXCEPTION;
+            integrity_viol			EXCEPTION;
+            TYPE intarray IS TABLE OF INTEGER index by binary_integer;
+            TYPE numarray IS TABLE OF NUMBER index by binary_integer;
+            TYPE distarray IS TABLE OF VARCHAR(24) index by binary_integer;
+            o_id_array intarray;
+            w_id_array intarray;
+            o_quantity_array intarray;
+            s_quantity_array intarray;
+            ol_line_number_array intarray;
+            amount_array numarray;
+            district_info distarray;
             BEGIN
-            --assignment below added due to error in appendix code
-            no_o_all_local := 0;
             SELECT c_discount, c_last, c_credit, w_tax
             INTO no_c_discount, no_c_last, no_c_credit, no_w_tax
             FROM customer, warehouse
-            WHERE warehouse.w_id = no_w_id AND customer.c_w_id = no_w_id AND
-            customer.c_d_id = no_d_id AND customer.c_id = no_c_id;
-            UPDATE district SET d_next_o_id = d_next_o_id + 1 WHERE d_id = no_d_id AND d_w_id = no_w_id RETURNING d_next_o_id, d_tax INTO no_d_next_o_id, no_d_tax;
-            o_id := no_d_next_o_id;
-            INSERT INTO ORDERS (o_id, o_d_id, o_w_id, o_c_id, o_entry_d, o_ol_cnt, o_all_local) VALUES (o_id, no_d_id, no_w_id, no_c_id, tstamp, no_o_ol_cnt, no_o_all_local);
-            INSERT INTO NEW_ORDER (no_o_id, no_d_id, no_w_id) VALUES (o_id, no_d_id, no_w_id);
-            --#2.4.1.4
-            rbk := round(DBMS_RANDOM(1,100));
+            WHERE warehouse.w_id = no_w_id AND customer.c_w_id = no_w_id AND customer.c_d_id = no_d_id AND customer.c_id = no_c_id;
+
             --#2.4.1.5
+            no_o_all_local := 1;
             FOR loop_counter IN 1 .. no_o_ol_cnt
             LOOP
-            IF ((loop_counter = no_o_ol_cnt) AND (rbk = 1))
-            THEN
-            no_ol_i_id := 100001;
-            ELSE
-            no_ol_i_id := round(DBMS_RANDOM(1,100000));
-            END IF;
+            o_id_array(loop_counter) := round(DBMS_RANDOM.value(low => 1, high => 100000));
+
             --#2.4.1.5.2
-            x := round(DBMS_RANDOM(1,100));
-            IF ( x > 1 )
+            IF ( DBMS_RANDOM.value >= 0.01 )
             THEN
-            no_ol_supply_w_id := no_w_id;
+            w_id_array(loop_counter) := no_w_id;
             ELSE
-            no_ol_supply_w_id := no_w_id;
-            --no_all_local is actually used before this point so following not beneficial
             no_o_all_local := 0;
-            WHILE ((no_ol_supply_w_id = no_w_id) AND (no_max_w_id != 1))
-            LOOP
-            no_ol_supply_w_id := round(DBMS_RANDOM(1,no_max_w_id));
-            END LOOP;
-            END IF;
-            --#2.4.1.5.3
-            no_ol_quantity := round(DBMS_RANDOM(1,10));
-            SELECT i_price, i_name, i_data INTO no_i_price, no_i_name, no_i_data
-            FROM item WHERE i_id = no_ol_i_id;
-            SELECT s_quantity, s_data, s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10
-            INTO no_s_quantity, no_s_data, no_s_dist_01, no_s_dist_02, no_s_dist_03, no_s_dist_04, no_s_dist_05, no_s_dist_06, no_s_dist_07, no_s_dist_08, no_s_dist_09, no_s_dist_10 FROM stock WHERE s_i_id = no_ol_i_id AND s_w_id = no_ol_supply_w_id;
-            IF ( no_s_quantity > no_ol_quantity )
-            THEN
-            no_s_quantity := ( no_s_quantity - no_ol_quantity );
-            ELSE
-            no_s_quantity := ( no_s_quantity - no_ol_quantity + 91 );
+            w_id_array(loop_counter) := 1 + mod(no_w_id + round(DBMS_RANDOM.value(low => 0, high => no_max_w_id-1)),no_max_w_id);
             END IF;
-            UPDATE stock SET s_quantity = no_s_quantity
-            WHERE s_i_id = no_ol_i_id
-            AND s_w_id = no_ol_supply_w_id;
-
-            no_ol_amount := (  no_ol_quantity * no_i_price * ( 1 + no_w_tax + no_d_tax ) * ( 1 - no_c_discount ) );
-
-            IF no_d_id = 1
-            THEN 
-            no_ol_dist_info := no_s_dist_01; 
-
-            ELSIF no_d_id = 2
-            THEN
-            no_ol_dist_info := no_s_dist_02;
 
-            ELSIF no_d_id = 3
-            THEN
-            no_ol_dist_info := no_s_dist_03;
-
-            ELSIF no_d_id = 4
-            THEN
-            no_ol_dist_info := no_s_dist_04;
-
-            ELSIF no_d_id = 5
-            THEN
-            no_ol_dist_info := no_s_dist_05;
-
-            ELSIF no_d_id = 6
-            THEN
-            no_ol_dist_info := no_s_dist_06;
-
-            ELSIF no_d_id = 7
-            THEN
-            no_ol_dist_info := no_s_dist_07;
+            --#2.4.1.5.3
+            o_quantity_array(loop_counter) := round(DBMS_RANDOM.value(low => 1, high => 10));
 
-            ELSIF no_d_id = 8
-            THEN
-            no_ol_dist_info := no_s_dist_08;
+            -- Take advantage of the fact that I'm looping to populate the array used to record order lines at the end
+            ol_line_number_array(loop_counter) := loop_counter;
+            END LOOP;
 
-            ELSIF no_d_id = 9
-            THEN
-            no_ol_dist_info := no_s_dist_09;
+            UPDATE district SET d_next_o_id = d_next_o_id + 1 WHERE d_id = no_d_id AND d_w_id = no_w_id RETURNING d_next_o_id, d_tax INTO no_d_next_o_id, no_d_tax;
 
-            ELSIF no_d_id = 10
-            THEN
-            no_ol_dist_info := no_s_dist_10;
+            INSERT INTO ORDERS (o_id, o_d_id, o_w_id, o_c_id, o_entry_d, o_ol_cnt, o_all_local) VALUES (no_d_next_o_id, no_d_id, no_w_id, no_c_id, timestamp2, no_o_ol_cnt, no_o_all_local);
+            INSERT INTO NEW_ORDER (no_o_id, no_d_id, no_w_id) VALUES (no_d_next_o_id, no_d_id, no_w_id);
+
+            -- The HammerDB implementation doesn't do the check for ORIGINAL (which should be done against i_data and s_data)
+            IF no_d_id = 1 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_01, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array, amount_array;
+            ELSIF no_d_id = 2 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_02, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 3 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_03, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 4 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_04, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 5 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_05, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 6 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_06, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 7 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_07, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 8 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_08, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 9 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_09, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
+            ELSIF no_d_id = 10 THEN
+            FORALL i IN 1 .. no_o_ol_cnt
+            UPDATE stock
+            SET s_quantity = (CASE WHEN s_quantity < ( o_quantity_array(i) + 10 ) THEN s_quantity + 91 ELSE s_quantity END) - o_quantity_array(i)
+            FROM item
+            WHERE i_id = o_id_array(i)
+            AND s_w_id = w_id_array(i)
+            AND i_id = o_id_array(i)
+            AND i_id = s_i_id
+            RETURNING s_dist_10, s_quantity, i_price * o_quantity_array(i) BULK COLLECT INTO district_info, s_quantity_array,amount_array;
             END IF;
 
-            INSERT INTO order_line (ol_o_id, ol_d_id, ol_w_id, ol_number, ol_i_id, ol_supply_w_id, ol_quantity, ol_amount, ol_dist_info)
-            VALUES (o_id, no_d_id, no_w_id, loop_counter, no_ol_i_id, no_ol_supply_w_id, no_ol_quantity, no_ol_amount, no_ol_dist_info);
-
+            -- Oracle return the TAX information to the client, presumably to do the calculation there.  HammerDB doesn't return it at all so I'll just calculate it here and do nothing with it
+            order_amount := 0;
+            FOR loop_counter IN 1 .. no_o_ol_cnt
+            LOOP
+            order_amount := order_amount + ( amount_array(loop_counter) );
             END LOOP;
+            order_amount := order_amount * ( 1 + no_w_tax + no_d_tax ) * ( 1 - no_c_discount );
+
+            FORALL i IN 1 .. no_o_ol_cnt
+            INSERT INTO order_line (ol_o_id, ol_d_id, ol_w_id, ol_number, ol_i_id, ol_supply_w_id, ol_quantity, ol_amount, ol_dist_info)
+            VALUES (no_d_next_o_id, no_d_id, no_w_id, ol_line_number_array(i), o_id_array(i), w_id_array(i), o_quantity_array(i), amount_array(i), district_info(i));
 
+            -- Rollback 1% of transactions
+            IF DBMS_RANDOM.value < 0.01 THEN
+            dbms_output.put_line('Rolling back');
+            ROLLBACK;
+            ELSE
             COMMIT;
+            END IF;
+
             EXCEPTION
-            WHEN serialization_failure OR deadlock_detected OR no_data_found
-            THEN ROLLBACK;
+            WHEN not_serializable OR deadlock OR snapshot_too_old OR integrity_viol --OR no_data_found
+            THEN
+            ROLLBACK;
         END; }
         set sql(3) { CREATE OR REPLACE PROCEDURE DELIVERY (
             d_w_id			INTEGER,
-            d_o_carrier_id		INTEGER,
-            tstamp		IN DATE )
+            d_o_carrier_id	INTEGER,
+            timestamp2		DATE
+            )
             IS
-            d_no_o_id		INTEGER;
-            d_d_id	           	INTEGER;
-            d_c_id	           	NUMBER;
-            d_ol_total		NUMBER;
-            loop_counter            INTEGER;
+            TYPE intarray IS TABLE OF INTEGER index by binary_integer;
+            dist_id_in_array    intarray;
+            dist_id_array       intarray;
+            o_id_array          intarray;
+            order_c_id          intarray;
+            sums                intarray;
+            ordcnt              INTEGER;
+
+            not_serializable		EXCEPTION;
+            deadlock			EXCEPTION;
+            snapshot_too_old		EXCEPTION;
             BEGIN
-            FOR loop_counter IN 1 .. 10
-            LOOP
-            d_d_id := loop_counter;
-            SELECT no_o_id INTO d_no_o_id FROM new_order WHERE no_w_id = d_w_id AND no_d_id = d_d_id ORDER BY no_o_id ASC LIMIT 1;
-            DELETE FROM new_order WHERE no_w_id = d_w_id AND no_d_id = d_d_id AND no_o_id = d_no_o_id;
-            SELECT o_c_id INTO d_c_id FROM orders
-            WHERE o_id = d_no_o_id AND o_d_id = d_d_id AND
-            o_w_id = d_w_id;
-            UPDATE orders SET o_carrier_id = d_o_carrier_id
-            WHERE o_id = d_no_o_id AND o_d_id = d_d_id AND
-            o_w_id = d_w_id;
-            UPDATE order_line SET ol_delivery_d = tstamp
-            WHERE ol_o_id = d_no_o_id AND ol_d_id = d_d_id AND
-            ol_w_id = d_w_id;
-            SELECT SUM(ol_amount) INTO d_ol_total
-            FROM order_line
-            WHERE ol_o_id = d_no_o_id AND ol_d_id = d_d_id
-            AND ol_w_id = d_w_id;
-            UPDATE customer SET c_balance = c_balance + d_ol_total
-            WHERE c_id = d_c_id AND c_d_id = d_d_id AND
-            c_w_id = d_w_id;
-            DBMS_OUTPUT.PUT_LINE('D: ' || d_d_id || 'O: ' || d_no_o_id || 'time ' || tstamp);
+            FOR i in 1 .. 10 LOOP
+            dist_id_in_array(i) := i;
             END LOOP;
-            COMMIT;
-            EXCEPTION
-            WHEN serialization_failure OR deadlock_detected OR no_data_found
-            THEN ROLLBACK;
-        END; }
-        set sql(4) { CREATE OR REPLACE PROCEDURE PAYMENT (
-            p_w_id			INTEGER,
-            p_d_id			INTEGER,
-            p_c_w_id		INTEGER,
-            p_c_d_id		INTEGER,
-            p_c_id			IN OUT NUMBER(5,0),
-            byname			INTEGER,
-            p_h_amount		NUMBER,
-            p_c_last		IN OUT VARCHAR2(16),
-            p_w_street_1		OUT VARCHAR2(20),
-            p_w_street_2		OUT VARCHAR2(20),
-            p_w_city		OUT VARCHAR2(20),
-            p_w_state		OUT CHAR(2),
-            p_w_zip			OUT CHAR(9),
-            p_d_street_1		OUT VARCHAR2(20),
-            p_d_street_2		OUT VARCHAR2(20),
-            p_d_city		OUT VARCHAR2(20),
-            p_d_state		OUT CHAR(2),
-            p_d_zip			OUT CHAR(9),
-            p_c_first		OUT VARCHAR2(16),
-            p_c_middle		OUT CHAR(2),
-            p_c_street_1		OUT VARCHAR2(20),
-            p_c_street_2		OUT VARCHAR2(20),
-            p_c_city		OUT VARCHAR2(20),
-            p_c_state		OUT CHAR(2),
-            p_c_zip			OUT CHAR(9),
-            p_c_phone		OUT CHAR(16),
-            p_c_since		OUT DATE,
-            p_c_credit		IN OUT CHAR(2),
-            p_c_credit_lim		OUT NUMBER(12, 2),
-            p_c_discount		OUT NUMBER(4, 4),
-            p_c_balance		IN OUT NUMBER(12, 2),
-            p_c_data		OUT VARCHAR2(500),
-            tstamp		IN DATE )
-            IS
-            namecnt			INTEGER;
-            p_d_name		VARCHAR2(11);
-            p_w_name		VARCHAR2(11);
-            p_c_new_data		VARCHAR2(500);
-            h_data			VARCHAR2(30);
-            CURSOR c_byname IS
-            SELECT c_first, c_middle, c_id,
-            c_street_1, c_street_2, c_city, c_state, c_zip,
-            c_phone, c_credit, c_credit_lim,
-            c_discount, c_balance, c_since
-            FROM customer
-            WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND c_last = p_c_last
-            ORDER BY c_first;
-            BEGIN
-            UPDATE warehouse SET w_ytd = w_ytd + p_h_amount
-            WHERE w_id = p_w_id;
-            SELECT w_street_1, w_street_2, w_city, w_state, w_zip, w_name
-            INTO p_w_street_1, p_w_street_2, p_w_city, p_w_state, p_w_zip, p_w_name
-            FROM warehouse
-            WHERE w_id = p_w_id;
-            UPDATE district SET d_ytd = d_ytd + p_h_amount
-            WHERE d_w_id = p_w_id AND d_id = p_d_id;
-            SELECT d_street_1, d_street_2, d_city, d_state, d_zip, d_name
-            INTO p_d_street_1, p_d_street_2, p_d_city, p_d_state, p_d_zip, p_d_name
-            FROM district
-            WHERE d_w_id = p_w_id AND d_id = p_d_id;
-            IF ( byname = 1 )
-            THEN
-            SELECT count(c_id) INTO namecnt
-            FROM customer
-            WHERE c_last = p_c_last AND c_d_id = p_c_d_id AND c_w_id = p_c_w_id;
-            OPEN c_byname;
-            IF ( MOD (namecnt, 2) = 1 )
-            THEN
-            namecnt := (namecnt + 1);
-            END IF;
-            FOR loop_counter IN 0 .. cast((namecnt/2) AS INTEGER)
-            LOOP
-            FETCH c_byname
-            INTO p_c_first, p_c_middle, p_c_id, p_c_street_1, p_c_street_2, p_c_city,
-            p_c_state, p_c_zip, p_c_phone, p_c_credit, p_c_credit_lim, p_c_discount, p_c_balance, p_c_since;
+
+            FORALL d IN 1..10
+            DELETE
+            FROM new_order
+            WHERE no_d_id = dist_id_in_array(d)
+            AND no_w_id = d_w_id
+            AND no_o_id = (select min (no_o_id)
+            from new_order
+            where no_d_id = dist_id_in_array(d)
+            and no_w_id = d_w_id)
+            RETURNING no_d_id, no_o_id BULK COLLECT INTO dist_id_array, o_id_array;
+
+            ordcnt := SQL%ROWCOUNT;
+
+            FORALL o in 1.. ordcnt
+            UPDATE orders
+            SET o_carrier_id = d_o_carrier_id
+            WHERE o_id = o_id_array (o)
+            AND o_d_id = dist_id_array(o)
+            AND o_w_id = d_w_id
+            RETURNING o_c_id BULK COLLECT INTO order_c_id;
+
+            FOR o in 1.. ordcnt LOOP
+            WITH s1 AS (
+            UPDATE order_line
+            SET ol_delivery_d = timestamp2
+            WHERE ol_w_id = d_w_id
+            AND ol_d_id = dist_id_array(o)
+            AND ol_o_id = o_id_array (o)
+            RETURNING ol_amount
+            )
+            SELECT sum(ol_amount) FROM s1 INTO sums(o);
             END LOOP;
-            CLOSE c_byname;
-            ELSE
-            SELECT c_first, c_middle, c_last,
-            c_street_1, c_street_2, c_city, c_state, c_zip,
-            c_phone, c_credit, c_credit_lim,
-            c_discount, c_balance, c_since
-            INTO p_c_first, p_c_middle, p_c_last,
-            p_c_street_1, p_c_street_2, p_c_city, p_c_state, p_c_zip,
-            p_c_phone, p_c_credit, p_c_credit_lim,
-            p_c_discount, p_c_balance, p_c_since
-            FROM customer
-            WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND c_id = p_c_id;
-            END IF;
-            p_c_balance := ( p_c_balance + p_h_amount );
-            IF p_c_credit = 'BC' 
-            THEN
-            SELECT c_data INTO p_c_data
-            FROM customer
-            WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND c_id = p_c_id;
-            -- The following statement in the TPC-C specification appendix is incorrect
-            -- copied setting of h_data from later on in the procedure to here as well
-            h_data := ( p_w_name || ' ' || p_d_name );
-            p_c_new_data := (TO_CHAR(p_c_id) || ' ' || TO_CHAR(p_c_d_id) || ' ' ||
-            TO_CHAR(p_c_w_id) || ' ' || TO_CHAR(p_d_id) || ' ' || TO_CHAR(p_w_id) || ' ' || TO_CHAR(p_h_amount,'9999.99') || TO_CHAR(tstamp) || h_data);
-            p_c_new_data := substr(CONCAT(p_c_new_data,p_c_data),1,500-(LENGTH(p_c_new_data)));
+
+            FORALL c IN 1.. ordcnt
             UPDATE customer
-            SET c_balance = p_c_balance, c_data = p_c_new_data
-            WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND
-            c_id = p_c_id;
-            ELSE
-            UPDATE customer SET c_balance = p_c_balance
-            WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND
-            c_id = p_c_id;
-            END IF;
-            --setting of h_data is here in the TPC-C appendix
-            h_data := ( p_w_name|| ' ' || p_d_name );
-            INSERT INTO history (h_c_d_id, h_c_w_id, h_c_id, h_d_id,
-            h_w_id, h_date, h_amount, h_data)
-            VALUES (p_c_d_id, p_c_w_id, p_c_id, p_d_id,
-            p_w_id, tstamp, p_h_amount, h_data);
+            SET c_balance = c_balance + sums(c)
+            -- Added this in for the refactor but it's not in the original (although it should be) so I've removed it, to be true to the original
+            --, c_delivery_cnt = c_delivery_cnt + 1
+            WHERE c_w_id = d_w_id
+            AND c_d_id = dist_id_array(c)
+            AND c_id = order_c_id(c);
+
             COMMIT;
+
             EXCEPTION
-            WHEN serialization_failure OR deadlock_detected OR no_data_found
-            THEN ROLLBACK;
+            WHEN not_serializable OR deadlock OR snapshot_too_old THEN
+            ROLLBACK;
+        END; }
+        set sql(4) { CREATE OR REPLACE PROCEDURE PAYMENT (
+        p_w_id			INTEGER,
+        p_d_id			INTEGER,
+        p_c_w_id		INTEGER,
+        p_c_d_id		INTEGER,
+        p_c_id			IN OUT INTEGER,
+        byname			INTEGER,
+        p_h_amount		NUMBER,
+        p_c_last		IN OUT VARCHAR2,
+        p_w_street_1	OUT VARCHAR2,
+        p_w_street_2	OUT VARCHAR2,
+        p_w_city		OUT VARCHAR2,
+        p_w_state		OUT VARCHAR2,
+        p_w_zip			OUT VARCHAR2,
+        p_d_street_1	OUT VARCHAR2,
+        p_d_street_2	OUT VARCHAR2,
+        p_d_city		OUT VARCHAR2,
+        p_d_state		OUT VARCHAR2,
+        p_d_zip			OUT VARCHAR2,
+        p_c_first		OUT VARCHAR2,
+        p_c_middle		OUT VARCHAR2,
+        p_c_street_1	OUT VARCHAR2,
+        p_c_street_2	OUT VARCHAR2,
+        p_c_city		OUT VARCHAR2,
+        p_c_state		OUT VARCHAR2,
+        p_c_zip			OUT VARCHAR2,
+        p_c_phone		OUT VARCHAR2,
+        p_c_since		OUT DATE,
+        p_c_credit		IN OUT VARCHAR2,
+        p_c_credit_lim	OUT NUMBER,
+        p_c_discount	OUT NUMBER,
+        p_c_balance		IN OUT NUMBER,
+        p_c_data		OUT VARCHAR2,
+        timestamp2		IN DATE
+        )
+        IS
+        p_d_name		VARCHAR2(11);
+        p_w_name		VARCHAR2(11);
+        p_c_new_data	VARCHAR2(500);
+        h_data			VARCHAR2(30);
+
+        TYPE rowidarray IS TABLE OF ROWID INDEX BY BINARY_INTEGER;
+        cust_rowid ROWID;
+        row_id rowidarray;
+        c_num BINARY_INTEGER;
+
+        CURSOR c_byname IS
+        SELECT rowid
+        FROM customer
+        WHERE c_w_id = p_c_w_id AND c_d_id = p_c_d_id AND c_last = p_c_last
+        ORDER BY c_first;
+
+        not_serializable		EXCEPTION;
+        deadlock			EXCEPTION;
+        snapshot_too_old		EXCEPTION;
+
+        BEGIN
+        IF ( byname = 1 )
+        THEN
+        c_num := 0;
+        FOR c_id_rec IN c_byname LOOP
+        c_num := c_num + 1;
+        row_id(c_num) := c_id_rec.rowid;
+        END LOOP;
+        cust_rowid := row_id (cast((c_num + 1) / 2 as ROWID));
+
+        UPDATE customer
+        SET c_balance = c_balance - p_h_amount
+        --c_ytd_payment = c_ytd_payment + hist_amount,
+        --c_payment_cnt = c_payment_cnt + 1
+        WHERE rowid = cust_rowid
+        RETURNING c_id, c_first, c_middle, c_last, c_street_1, c_street_2,
+        c_city, c_state, c_zip, c_phone,
+        c_since, c_credit, c_credit_lim,
+        c_discount, c_balance
+        INTO p_c_id, p_c_first, p_c_middle, p_c_last, p_c_street_1, p_c_street_2,
+        p_c_city, p_c_state, p_c_zip, p_c_phone,
+        p_c_since, p_c_credit, p_c_credit_lim,
+        p_c_discount, p_c_balance;
+        ELSE
+        UPDATE customer
+        SET c_balance = c_balance - p_h_amount
+        --c_ytd_payment = c_ytd_payment + hist_amount,
+        --c_payment_cnt = c_payment_cnt + 1
+        WHERE c_id = p_c_id AND c_d_id = p_c_d_id AND c_w_id = p_c_w_id
+        RETURNING rowid, c_first, c_middle, c_last, c_street_1, c_street_2,
+        c_city, c_state, c_zip, c_phone,
+        c_since, c_credit, c_credit_lim,
+        c_discount, c_balance
+        INTO cust_rowid, p_c_first, p_c_middle, p_c_last, p_c_street_1, p_c_street_2,
+        p_c_city, p_c_state, p_c_zip, p_c_phone,
+        p_c_since, p_c_credit, p_c_credit_lim,
+        p_c_discount, p_c_balance;
+        END IF;
+
+        IF p_c_credit = 'BC' THEN
+        UPDATE customer
+        SET c_data = substr ((to_char (p_c_id) || ' ' ||
+        to_char (p_c_d_id) || ' ' ||
+        to_char (p_c_w_id) || ' ' ||
+        to_char (p_d_id) || ' ' ||
+        to_char (p_w_id) || ' ' ||
+        to_char (p_h_amount, '9999.99') || ' | ') || c_data, 1, 500)
+        WHERE rowid = cust_rowid
+        RETURNING substr (c_data, 1, 200) INTO p_c_data;
+        ELSE
+        p_c_data := ' ';
+        END IF;
+
+        UPDATE district
+        SET d_ytd = d_ytd + p_h_amount
+        WHERE d_id = p_d_id
+        AND d_w_id = p_w_id
+        RETURNING d_name, d_street_1, d_street_2, d_city,d_state, d_zip
+        INTO p_d_name, p_d_street_1, p_d_street_2, p_d_city, p_d_state, p_d_zip;
+
+        UPDATE warehouse
+        SET w_ytd = w_ytd + p_h_amount
+        WHERE w_id = p_w_id
+        RETURNING w_name, w_street_1, w_street_2, w_city, w_state, w_zip
+        INTO p_w_name, p_w_street_1, p_w_street_2, p_w_city, p_w_state, p_w_zip;
+
+        INSERT INTO history
+        (h_c_id, h_c_d_id, h_c_w_id, h_d_id, h_w_id, h_date,h_amount,h_data)
+        VALUES
+        (p_c_id, p_c_d_id, p_c_w_id, p_d_id, p_w_id, timestamp2, p_h_amount, p_w_name || ' ' || p_d_name);
+
+        COMMIT;
+
+        EXCEPTION
+        WHEN not_serializable OR deadlock OR snapshot_too_old
+        THEN
+        ROLLBACK;
         END; }
         set sql(5) { CREATE OR REPLACE PROCEDURE OSTAT (
-            os_w_id			INTEGER,
-            os_d_id			INTEGER,
-            os_c_id			IN OUT INTEGER,
-            byname			INTEGER,
-            os_c_last		IN OUT VARCHAR2,
-            os_c_first		OUT VARCHAR2,
-            os_c_middle		OUT VARCHAR2,
-            os_c_balance		OUT NUMBER,
-            os_o_id			OUT INTEGER,
-            os_entdate		OUT DATE,
-            os_o_carrier_id		OUT INTEGER )
-            IS
-            TYPE numbertable IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
-            os_ol_i_id numbertable;	
-            os_ol_supply_w_id numbertable;	
-            os_ol_quantity numbertable;	
-            TYPE amounttable IS TABLE OF NUMBER(6,2) INDEX BY BINARY_INTEGER;
-            os_ol_amount amounttable;
-            TYPE datetable IS TABLE OF DATE INDEX BY BINARY_INTEGER;
-            os_ol_delivery_d datetable;
-            namecnt			INTEGER;
-            i			BINARY_INTEGER;
-            CURSOR c_name IS
-            SELECT c_balance, c_first, c_middle, c_id
-            FROM customer
-            WHERE c_last = os_c_last AND c_d_id = os_d_id AND c_w_id = os_w_id
-            ORDER BY c_first;
-            CURSOR c_line IS
-            SELECT ol_i_id, ol_supply_w_id, ol_quantity,
-            ol_amount, ol_delivery_d
-            FROM order_line
-            WHERE ol_o_id = os_o_id AND ol_d_id = os_d_id AND ol_w_id = os_w_id;
-            os_c_line c_line%ROWTYPE;
-            BEGIN
-            IF ( byname = 1 )
-            THEN
-            SELECT count(c_id) INTO namecnt
-            FROM customer
-            WHERE c_last = os_c_last AND c_d_id = os_d_id AND c_w_id = os_w_id;
-            IF ( MOD (namecnt, 2) = 1 )
-            THEN
-            namecnt := (namecnt + 1);
-            END IF;
-            OPEN c_name;
-            FOR loop_counter IN 0 .. cast((namecnt/2) AS INTEGER)
-            LOOP
-            FETCH c_name  
-            INTO os_c_balance, os_c_first, os_c_middle, os_c_id;
-            END LOOP;
-            close c_name;
-            ELSE
-            SELECT c_balance, c_first, c_middle, c_last
-            INTO os_c_balance, os_c_first, os_c_middle, os_c_last
-            FROM customer
-            WHERE c_id = os_c_id AND c_d_id = os_d_id AND c_w_id = os_w_id;
-            END IF;
-            SELECT o_id, o_carrier_id, o_entry_d 
-            INTO os_o_id, os_o_carrier_id, os_entdate
-            FROM
-            (SELECT o_id, o_carrier_id, o_entry_d
-            FROM orders where o_d_id = os_d_id AND o_w_id = os_w_id and o_c_id=os_c_id
-            ORDER BY o_id DESC)
-            WHERE ROWNUM = 1;
-            EXCEPTION
-            WHEN NO_DATA_FOUND THEN
-            dbms_output.put_line('No orders for customer');
-            END;
-            i := 0;
-            FOR os_c_line IN c_line
-            LOOP
-            os_ol_i_id(i) := os_c_line.ol_i_id;
-            os_ol_supply_w_id(i) := os_c_line.ol_supply_w_id;
-            os_ol_quantity(i) := os_c_line.ol_quantity;
-            os_ol_amount(i) := os_c_line.ol_amount;
-            os_ol_delivery_d(i) := os_c_line.ol_delivery_d;
-            i := i+1;
-            END LOOP;
-            COMMIT;
-            EXCEPTION
-            WHEN serialization_failure OR deadlock_detected OR no_data_found
-            THEN ROLLBACK;
+        os_w_id			INTEGER,
+        os_d_id			INTEGER,
+        os_c_id			IN OUT INTEGER,
+        byname			INTEGER,
+        os_c_last		IN OUT VARCHAR2,
+        os_c_first		OUT VARCHAR2,
+        os_c_middle		OUT VARCHAR2,
+        os_c_balance		OUT NUMBER,
+        os_o_id			OUT INTEGER,
+        os_entdate		OUT DATE,
+        os_o_carrier_id		OUT INTEGER
+        )
+        IS
+        TYPE rowidarray IS TABLE OF ROWID INDEX BY BINARY_INTEGER;
+        cust_rowid ROWID;
+        row_id rowidarray;
+        c_num BINARY_INTEGER;
+
+        CURSOR c_byname
+        IS
+        SELECT rowid
+        FROM customer
+        WHERE c_w_id = os_w_id AND c_d_id = os_d_id AND c_last = os_c_last
+        ORDER BY c_first;
+
+        i			BINARY_INTEGER;
+        CURSOR c_line IS
+        SELECT ol_i_id, ol_supply_w_id, ol_quantity,
+        ol_amount, ol_delivery_d
+        FROM order_line
+        WHERE ol_o_id = os_o_id AND ol_d_id = os_d_id AND ol_w_id = os_w_id;
+
+
+        TYPE intarray IS TABLE OF INTEGER index by binary_integer;
+        os_ol_i_id intarray;
+        os_ol_supply_w_id intarray;
+        os_ol_quantity intarray;
+
+        TYPE datetable IS TABLE OF DATE INDEX BY BINARY_INTEGER;
+        os_ol_delivery_d datetable;
+
+        TYPE numarray IS TABLE OF NUMBER index by binary_integer;
+        os_ol_amount numarray;
+
+        not_serializable		EXCEPTION;
+        deadlock			EXCEPTION;
+        snapshot_too_old		EXCEPTION;
+        BEGIN
+        IF ( byname = 1 )
+        THEN
+        c_num := 0;
+        FOR c_id_rec IN c_byname LOOP
+        c_num := c_num + 1;
+        row_id(c_num) := c_id_rec.rowid;
+        END LOOP;
+        cust_rowid := row_id (cast((c_num + 1) / 2 as ROWID));
+
+        SELECT c_balance, c_first, c_middle, c_last, c_id
+        INTO os_c_balance, os_c_first, os_c_middle, os_c_last, os_c_id
+        FROM customer
+        WHERE rowid = cust_rowid;
+        ELSE
+        SELECT c_balance, c_first, c_middle, c_last, rowid
+        INTO os_c_balance, os_c_first, os_c_middle, os_c_last, cust_rowid
+        FROM customer
+        WHERE c_id = os_c_id AND c_d_id = os_d_id AND c_w_id = os_w_id;
+        END IF;
+
+        -- The following statement in the TPC-C specification appendix is incorrect
+        -- as it does not include the where clause and does not restrict the
+        -- results set giving an ORA-01422.
+        -- The statement has been modified in accordance with the
+        -- descriptive specification as follows:
+        -- The row in the ORDER table with matching O_W_ID (equals C_W_ID),
+        -- O_D_ID (equals C_D_ID), O_C_ID (equals C_ID), and with the largest
+        -- existing O_ID, is selected. This is the most recent order placed by that
+        -- customer. O_ID, O_ENTRY_D, and O_CARRIER_ID are retrieved.
+        BEGIN
+        SELECT o_id, o_carrier_id, o_entry_d
+        INTO os_o_id, os_o_carrier_id, os_entdate
+        FROM (SELECT o_id, o_carrier_id, o_entry_d
+        FROM orders
+        WHERE o_d_id = os_d_id AND o_w_id = os_w_id and o_c_id=os_c_id
+        ORDER BY o_id DESC)
+        WHERE ROWNUM = 1;
+        EXCEPTION
+        WHEN NO_DATA_FOUND THEN
+        dbms_output.put_line('No orders for customer');
+        END;
+
+        i := 0;
+        FOR os_c_line IN c_line
+        LOOP
+        os_ol_i_id(i) := os_c_line.ol_i_id;
+        os_ol_supply_w_id(i) := os_c_line.ol_supply_w_id;
+        os_ol_quantity(i) := os_c_line.ol_quantity;
+        os_ol_amount(i) := os_c_line.ol_amount;
+        os_ol_delivery_d(i) := os_c_line.ol_delivery_d;
+        i := i + 1;
+        END LOOP;
+        COMMIT;
+
+        EXCEPTION WHEN not_serializable OR deadlock OR snapshot_too_old THEN
+        ROLLBACK;
         END; }
         set sql(6) { CREATE OR REPLACE PROCEDURE SLEV (
-            st_w_id			INTEGER,
-            st_d_id			INTEGER,
-            threshold		INTEGER,
-            stock_count		OUT INTEGER )
-            IS 
-            st_o_id			NUMBER;	
-            BEGIN
-            SELECT d_next_o_id INTO st_o_id
-            FROM district
-            WHERE d_w_id=st_w_id AND d_id=st_d_id;
-            SELECT COUNT(DISTINCT (s_i_id)) INTO stock_count
-            FROM order_line, stock
-            WHERE ol_w_id = st_w_id AND
-            ol_d_id = st_d_id AND (ol_o_id < st_o_id) AND
-            ol_o_id >= (st_o_id - 20) AND s_w_id = st_w_id AND
-            s_i_id = ol_i_id AND s_quantity < threshold;
-            COMMIT;
-            EXCEPTION
-            WHEN serialization_failure OR deadlock_detected OR no_data_found
-            THEN ROLLBACK;
+        st_w_id			INTEGER,
+        st_d_id			INTEGER,
+        threshold		INTEGER,
+        stock_count		OUT INTEGER
+        )
+        IS
+        st_o_id			NUMBER;
+        not_serializable		EXCEPTION;
+        deadlock			EXCEPTION;
+        snapshot_too_old		EXCEPTION;
+        BEGIN
+        SELECT COUNT(DISTINCT (s_i_id))
+        INTO stock_count
+        FROM order_line, stock, district
+        WHERE d_id=st_d_id
+        AND d_w_id=st_w_id
+        AND d_id = ol_d_id
+        AND d_w_id = ol_w_id
+        AND ol_i_id = s_i_id
+        AND ol_w_id = s_w_id
+        AND s_quantity < threshold
+        AND ol_o_id BETWEEN (d_next_o_id - 20) AND (d_next_o_id - 1);
+
+        COMMIT;
+        EXCEPTION
+        WHEN not_serializable OR deadlock OR snapshot_too_old THEN
+        ROLLBACK;
         END; }
         if { $citus_compatible eq "true" } {
             set sql(7) { SELECT create_distributed_function('dbms_random(int,int)') }
@@ -1704,11 +1825,24 @@ proc CreateTables { lda ora_compatible citus_compatible num_part } {
     }
 }
 
-proc CreateIndexes { lda } {
+proc CreateIndexes { lda ora_compatible } {
     puts "CREATING TPCC INDEXES"
-    set sql(1) "CREATE UNIQUE INDEX CUSTOMER_I2 ON CUSTOMER USING BTREE (C_W_ID, C_D_ID, C_LAST, C_FIRST, C_ID)"
-    set sql(2) "CREATE UNIQUE INDEX ORDERS_I2 ON ORDERS USING BTREE (O_W_ID, O_D_ID, O_C_ID, O_ID)"
-    for { set i 1 } { $i <= 2 } { incr i } {
+    if { $ora_compatible eq "true" } {
+        set stmt_cnt 8
+        set sql(1) "CREATE UNIQUE INDEX CUSTOMER_I1 ON CUSTOMER (C_W_ID, C_D_ID, C_ID)"
+        set sql(2) "CREATE UNIQUE INDEX CUSTOMER_I2 ON CUSTOMER (C_LAST, C_D_ID, C_W_ID, C_FIRST)"
+        set sql(3) "CREATE UNIQUE INDEX DISTRICT_I1 ON DISTRICT (D_W_ID, D_ID)"
+        set sql(4) "CREATE UNIQUE INDEX ITEM_I1 ON ITEM (I_ID)"
+        set sql(5) "CREATE UNIQUE INDEX ORDERS_I1 ON ORDERS (O_W_ID, O_D_ID, O_ID)"
+        set sql(6) "CREATE UNIQUE INDEX ORDERS_I2 ON ORDERS (O_W_ID, O_D_ID, O_C_ID, O_ID)"
+        set sql(7) "CREATE UNIQUE INDEX STOCK_I1 ON STOCK (S_I_ID, S_W_ID)"
+        set sql(8) "CREATE UNIQUE INDEX WAREHOUSE_I1 ON WAREHOUSE (W_ID)"
+    } else {
+        set stmt_cnt 2
+        set sql(1) "CREATE UNIQUE INDEX CUSTOMER_I2 ON CUSTOMER USING BTREE (C_W_ID, C_D_ID, C_LAST, C_FIRST, C_ID)"
+        set sql(2) "CREATE UNIQUE INDEX ORDERS_I2 ON ORDERS USING BTREE (O_W_ID, O_D_ID, O_C_ID, O_ID)"
+    }
+    for { set i 1 } { $i <= $stmt_cnt } { incr i } {
         set result [ pg_exec $lda $sql($i) ]
         if {[pg_result $result -status] != "PGRES_COMMAND_OK"} {
             error "[pg_result $result -error]"
@@ -2190,7 +2324,7 @@ proc do_tpcc { host port sslmode count_ware superuser superuser_password default
         }
     }
     if { $threaded eq "SINGLE-THREADED" || $threaded eq "MULTI-THREADED" && $myposition eq 1 } {
-        CreateIndexes $lda
+        CreateIndexes $lda $ora_compatible
         CreateStoredProcs $lda $ora_compatible $citus_compatible $pg_storedprocs
         GatherStatistics $lda 
         puts "[ string toupper $user ] SCHEMA COMPLETE"
@@ -2555,7 +2689,7 @@ proc neword { lda no_w_id w_id_input RAISEERROR ora_compatible pg_storedprocs }
     #2.4.1.6 order entry date O_ENTRY_D generated by SUT
     set date [ gettimestamp ]
     if { $ora_compatible eq "true" } {
-        set result [pg_exec $lda "exec neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,0,TO_TIMESTAMP($date,'YYYYMMDDHH24MISS'))" ]
+        set result [pg_exec $lda "exec neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,TO_TIMESTAMP($date,'YYYYMMDDHH24MISS'))" ]
     } else {
         if { $pg_storedprocs eq "true" } {
             set result [pg_exec $lda "call neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,0.0,'','',0.0,0.0,0,TO_TIMESTAMP('$date','YYYYMMDDHH24MISS')::timestamp without time zone)" ]
@@ -3000,7 +3134,7 @@ switch $myposition {
             #2.4.1.6 order entry date O_ENTRY_D generated by SUT
             set date [ gettimestamp ]
             if { $ora_compatible eq "true" } {
-                set result [pg_exec $lda "exec neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,0,TO_TIMESTAMP($date,'YYYYMMDDHH24MISS'))" ]
+                set result [pg_exec $lda "exec neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,TO_TIMESTAMP($date,'YYYYMMDDHH24MISS'))" ]
             } else {
                 if { $pg_storedprocs eq "true" } {
                     set result [pg_exec $lda "call neword($no_w_id,$w_id_input,$no_d_id,$no_c_id,$ol_cnt,0.0,'','',0.0,0.0,0,TO_TIMESTAMP('$date','YYYYMMDDHH24MISS')::timestamp without time zone)" ]
-- 
2.39.2

