from datetime import datetime
from dataclasses import dataclass
from pathlib import Path
# typing.Self available starting python3.11
import typing
import os
import sys
import textwrap

@dataclass
class EnvironmentVariable:
    '''
    Dataclass meant to represent an environment variable
    '''
    name: str # name of the variable
    default: str = None # default to use if not found
    value: typing.Any = None # final value stored
    environment: bool = False # whether the value was from
    cwd: Path = None # Path to assume when expanding relative paths
    type: typing.Type = None # environment variable type
    help: str = '' # help string
    full_help: str = '' # include help and additional info
    required: bool = False
    secret: bool = False
    error: str = ''
    success: str = ''
    valid: bool = False
    validation_callback: typing.Callable[[typing.Any], typing.Tuple[bool, str]] = lambda x: (True, 'Default callback') # expects a validation function which returns if valid and a message

    def __post_init__(self) -> None:
        # check if the value is from the environment
        self.environment = os.getenv(self.name, None)
        # store final value from environment or default
        self.value = os.getenv(self.name, self.default)

    def print_help(self):
        help = textwrap.dedent(f'''
        {self.name}
        environment: {self.environment if not self.secret else '<secret>'}
        default: {self.default}
        final: {self.value if not self.secret else '<secret>'}
        type: {self.type.__name__}
        help: {self.help}''')
        print(help)

    def validate(self):
        if self.required and self.environment is not None:
            self.valid = False
            self.error = Exception('You must define the variable')
            return

        # check for invalid type
        try:
            self.value = self.type(self.value)
            if self.type == Path and self.value.resolve() != self.value:
                self.value = (self.cwd / self.value).resolve()
        except Exception as e:
            self.valid = False
            self.error = e
            return

        # check against validation callback
        valid, message = self.validation_callback(self.value)
        if not valid:
            self.valid = False
            self.error = message
            return
        
        self.valid = True
        self.success = ''


@dataclass
class Arguments:
    args: list[EnvironmentVariable] = None

    def __post_init__(self):
        pass

    def validate(self):
        for arg in self.args:
            arg.validate()

    def print(self):
        for arg in self.args:
            arg.print_help()

    def save(self, directory: Path, filename='environment.test'):
        filepath = directory / filename
        filepath.touch()
        with open(filepath, 'w') as f:
            f.writelines(f'# File autogenerated and overriden upon every call \n')
            f.writelines(f'# Date: { datetime.now().strftime("%Y-%m-%dT%H:%M:%S%z") }\n')
            f.writelines('\n')
            for arg in self.args:
                f.writelines(f'# {arg.help}\n# {arg.error}\n' if arg.error else f'# {arg.help}\n')
                f.writelines(f'#export {arg.name}="{arg.value}"\n' if arg.error else f'export {arg.name}="{arg.value}"\n')
                f.writelines('\n')

    def exit(self):
        for arg in self.args:
            if not arg.valid:
                exit(1)
        exit(0)
